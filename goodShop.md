DRAFT
# GoodShop

## File Structure
TBD

## API
```typescript
interface Category {
  id: string;
  type: string;
  label: string;
}

interface Good {
  categoryTypeId: string;
  description: string;
  id: string;
  img: string;
  label: string;
  price: string;
}

interface GoodInCart {
  good: Good;
  count: number; // кол-во товаров в корзине
  id: string; // id товара
}

interface GoodsSearch {
  ids: string; // выбрать по id, exmaple ids=1,2,3
  categoryTypeIds: string; // выбрать по id категория, example categoryTypeIds=1,2,3
  minPrice: number; // выбрать с ценой не более максимально указанной
  maxPrice: number; // выбрать с ценой не менее минимально указанной
  text: string; // выбрать по содержанию указанной подстроки в названии
  limit: number; // количество возвращаемых товаров, по умолчанию 20
  offset: number; // смещение относительно начала.
  sortBy: keyof Good; // по какому полю бек сортирует товары, по умолчанию по id
  sortDirection: 'asc' | 'desc'; // как сортировать asc - по возрастанию desc - по убыванию, по умолчанию asc
}

Для сортировки в таблице используем sortBy + sortDirection.

Для количества записей на одной странице таблицы используем `limit`

Пагинацию делаем с помощью `offset`. На первой странице offset=0, каждая последующая страница увеличивает offset на размер limit. Например, если на странице выводим за раз 20 товаров (limit=20), то имеем:
offest=0&limit=20 - выбрать первые 20 товаров.
offest=20&limit=20 - выбрать 20 товаров пропустив первые 20, те с 21 по 40
offest=40&limit=20 - выбрать 20 товаров пропустив первые 40, те с 41 по 60
```

| pathname                | method   | Body                                | response                                                  | search                                                      |
| ----------------------- | :------: | :---------------------------------: |---------------------------------------------------------- | ----------------------------------------------------------- |
| /api/categories         | GET      | -                                   | { categories: Category[] }                                | ids: string - id категорий // example ids=1,2,3             |
| /api/popular_categories | GET      | -                                   | { category: Category; items: Good[] }                     |                                                             |
| /api/goods              | GET      | -                                   | { items: Good[]; total: number }                          | GoodsSearch                                                 |
| /api/login              | POST     | { login: string; password: string } | { login: string; token: string }                          |                                                             |
| /api/registration       | POST     | { login: string; password: string } | { user: { login: string; password: string; id: string } } |                                                             |
| /api/cart               | GET      | -                                   | GoodInCart[]                                              |                                                             |
| /api/cart               | PUT      | GoodInCart                          | GoodInCart[]                                              |                                                             |                             |


## Base
1. Создать в отдельном репозитории проект с помощью `create-react-app --template typescript` (если не уверены в своих силах, можно делать на js)
2. Убедиться, что в проекте настроены [абсолютный импорты](#webpack-aliases)
3. Установить библиотеки `redux-toolkit`, `react-redux`, `react-router`. Обернуть приложение в провадйеры редакса и роутера

## Стартовая страница
1. Создать компонент `<Menu />` с отображение категорий товаров (`/api/categories`)
2. Создать компонент `<Card />` который выводит информацию о товаре (label, price, img). Все карточки должны быть одинакового размера, независимо от размеров картинки. При клике на карточку должен осуществляться переход на страницу конкретного товара.
3. Создать компонент категории товаров `<GoodCategory />` (Название категории + карточки с товарами), который принимает в пропсах одну категории товаров и выводит список товаров данной категории. Название категории выводим в шапку, товары мапим в карточку `<Card />` из п.2
4. Создать компонент `<Footer />` с произвольным текстом внутри.
5. Создать компонент `<Header />`. Должен отображаться на всех роутах. Содержит в себе логотип (ссылка на главную страницу).
7. Создать компонент `<MainPage />`, который выводит все наши выше созданные компоненты (`<Menu />` / `<GoodCategory />` / `<Footer />` / `<Header />`)
    - Для создания структуры разметки использовать компоненты Row и Col из antd (можно сначала написать на обычных дивах и потом перевести на antd)
    - Для вывода популярных категорий используем ендопинт `/api/popular_categories` и компонент `<GoodCategory />`

![main_page](https://user-images.githubusercontent.com/32076718/175161043-e3a68113-fbff-49d5-800b-8a4b569f3561.png)

# Страница категории
1. Создать компонент `<CategoryPage />`, который будет выводить информацию по отдельно взятой категории (переиспользуем уже существующий компонент категории, который у нас на главной странице). Список товаров категории берем с бека по типу (`/api/goods` и квери параметр `categoryTypeIds` ), тип получаем из роутов нашего приложения (например роут нашего приложения может выглядеть как `category/:id`). Если нужная категория не найдена (бек отдаст 404) - выводим сообщение "Категория не найдена, вернуться назад". Если бек отдал пустой массив - выводим сообщение "Пока тут пусто, но мы скоро добавим новые товары. Вернуться назад"
2. Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории (получаем историю из хука useHistory и вызываем у нее метод goBack). ```const history = useHistory(); history.goBack();```

## Страница с отдельным товаром
1. Создать компонент `<ProductPage />` доступный по соответствующему роуту, который выводит картинку / цена / название / описание
2. Получаем товар с бека по id из роутов (например роут нашего приложения может выглядеть как `good/:id`). Если не смогли найти продукт - показываем сообщение "Продукт не найден, вернуться назад".  Слово назад должно быть ссылкой, которая перемещает пользователя назад по истории.
3. Товар можно добавлять в корзину: есть кнопку `+` и `-` которые увеличивают и уменьшают кол-во данного товара в коризне. Исползовать ендопинт PUT `api/cart`

## Страница корзины
1. Добавить в `<Header />` ссылку на страницу с корзиной (иконка с кол-вом товаров в корзине)
2. Выводим таблицу со всеми товарами в корзине (`api/cart`). Можно увеличивать уменьшать выбранное кол-во товаров.
3. Есть кнопка "Купить"

## Страница со всеми товарами
0. Доступна только для администратора (роль пользователя 'admin')
1. Создать компонент GoodsPage
2. Выводить его по урлу "/goods"
3. Добавить ссылку на эту страницу в меню или хедер
4. Добавить на страницу GoodsPage таблицу с товарами:
    + Таблица должна иметь пагинацию и опцию выбора кол-ва отображаемых за раз строк (используем для этого квери параметры limit (по умолчанию на беке лимит равен 20) и offset)
    + На странице должны присутствовать фильтры:
        - Текстовый поиск (квери параметр text)
        - Мультиселект выбора категорий (квери параметр categoryTypeIds)
        - Слайдер выбора мин и макс цены от 0 до 1000  (квери параметры  minPrice и maxPrice)
        - При изменении любого фильтра сбрасываем пагинацию на первую страницу
        - При изменении фильтра запрос делать на бек с дебаунс задержкой 1,5с
    + При клике на строку с товаром делаем переход на страницу товара
    + Если фильтр пользователем не установлен - на бек соответствующий квери параметр не шлем
    + Колонку цены и названия можно сортировать (квери параметры sortBy=ПОЛЕ_ПО_КОТОРОМУ_ХОТИМ_СОРТИРОВАТЬ и sortDirection=ASC_ИЛИ_DESC для указания направления по возрастанию или убыванию (по умолчанию бек сортирует по возрастанию), например /goods?sortBy=price&sortDirection=asc).
    + На время загрузки (обновления) данных с бека в таблице показывается лоадер
5. TBD: Можно удалять товары (DELETE `api/goods`)
6. TBD: Можно добавлять товары
7. TBD: Можно редактировать товары

## Страница логина
1. Создать компонент LoginPage
2. Выводить его по урлу "/login"
3. Добавить в компонент 2 инпута (логин и пароль) и 2 кнопки (войти и зарегистрироваться)
4. Кнопка зарегистрироваться должна вести на страницу "/registration"
5. По нажатию на кнопку войти:
    5.1. Валидация полей - если поле не заполненно показываем под ним сообщение с ошибкой "обязательное поле"
    5.2. Делаем запрос на бек `/api/login` и в случае успеха показываем успешную нотификацию "Успешный вход" и делаем редирект на главную страницу. В ответе с бека будет токен, сетаем его в локатстор. Сетаем переменную isAuth в редаксе на true.
    5.3. В случае ошибки с бека показываем ошибочную нотификацию "Неверный пользователь"
    5.4. Как только начинает печатать в любом инпуте должна убираться ошибка соответствующего инпута и ошибка под кнопками
6. Добавить в `<Header />` email залогиненного юзера и кнопку "Выйти". По нажатию на кнопку - чистим токен в локалстор, сетаем переменную isAuth в редаксе на false.
7. При старте приложения пытаемся найти токен в локалстор, если он там есть - используем его и считаем юзера залогиненым (isAuth = true)

## Страница Регистрации
1. Делаем страницу RegistrationPage
2. Отображаем ее по роуту "/registration"
3. На странице должны быть поля для заполнения и кнопки "Зарегистрироваться" и "Отмена"
4. Кнопка "Отмена" возвращает на главную страницу
5. Кнопка "Зарегистрироваться" еще раз валидирует все поля и если они валидны - делаем запрос на бек (`/api/registration`), в случае успеха показывает успешный тост "Успешная регистрация" и делает редирект на главную страницу, иначе показывает ошибочный тост "Проверьте корректность заполнения формы"

Для валидации можно использовать библиотеку [yup](https://github.com/jquense/yup). Там много готовых правил валидации и простое в использовании api.

Должны быть следующие поля для заполнения:

| Поле                           | Тип                | Обязательное | Доп правила валидации |
| ------------------------------ | ------------------ | --- | ------------------------------ |
| Имя                            | Текстовый инпут     | Да  | содержит 2+ символа |
| Фамилия                        | Текстовый инпут     | Нет | содержит 2+ символа |
| Почта (будет у нас логином)    | Текстовый инпут     | Да  | либо проверка на наличие "@" и минимум по 2 символа с каждой стороны от него, либо у yup есть валидация на email |
| Пароль / Повторите Пароль      | 2 текстовых инпута | Да  | Оба поля совпадают, не менее 6 символов |
| Пол                            | Радио кнопки       | Нет | - |
| Любимые категории              | Чекбоксы           | Да  | Выбрано минимум 2 категории. Список для чекбоксов брать из "/categories") |
| Выбор подписка на новости      | Свитчер (да / нет) | Да  | - |
| Дата рождения                  | Календарь          | Да  | Не раньше 1 янв 1930 года |
| Секр. вопрос для восст. пароля | 2 инпута (тип вопроса и ответ) | Нет | Если выбран тип - то ответ обязателен, иначе инпут с ответом не показываем |



## Логика поиска для инпута
1. Делаем в `<Header />` инпут с поиском и подсказками. При вводе значения с дебаунсом 1,5с идем на бекенд (`api/goods`) за товарами, используя для поиска квери параметр `text`
2. Показываем в дропдауне список из названий товаров, что отдал бек. При клике по товару - переходим на страницу товара.
3. Если ничего не нашлось, то показываем в дропдауне сообщение "Ничего не найдено, попробуйте изменить запрос"

## Авторизационные токены
1. Создать отдельный слайс в редаксе, который будет хранить информацию о юзере (логин / токен / флаг isAuth - по умолчанию false).
2. Форма регистрации в случае валидного заполнения должна делать запрос POST `api/registration` передавая значения формы и в случае успеха (помимо успешного тоста) должна делать редирект на страницу логина. В теле запроса передаем ```{ name, surname, email, password, gender, interests, isSubscribe, secret: { type, answer }, bornAt }```. Если какое-то поле не обязательно и юзер его не заполнил, то на бек его не шлем.
3. Страница логина должна делать запрос POST `api/login` передавая в теле ```{ login, password }```. В случае успеха с бека вернется информация о юзере, которую нужно положить в редакс и localStorage (класть и в стору и в localStorage можно в одной и той же санке). А также установить флаг isAuth=true.
4. При загрузке приложения считываем localStorage в поиске информации о юзере и, если нашли - кладем в редакс.
5. Если юзер не вошел (isAuth=false), то для него доступны ссылки и страницы "Войти" и "Регистрация", корзина не доступна.
6. Если юзер вошел (isAuth=true), то для него доступна корзина, доступна кнопка Выйти. И не доступны ссылки и страницы "Войти" и "Регистрация".
7. Кнопка выйти очищает данные о юзере и сторы и localstorage и устанавливает флаг isAuth=false.
8. Работа с корзиной теперь доступна лишь для зарегистрированных пользователей, соответственно все запросы надо подписывать токеном.
9. Для пользователей role='admin' доступна страница со всеми товарами.
10. Для удобства работы с токенами желательно применить паттерн синглтон для нашего класса Api [пример на js](./misc/singleton.js) / [пример на ts](./misc/singleton.ts)

## Прочее
1. Написать минимум 5 тестов для Api. Проверять корректность составления квери параметров и урлов [пример на ts.](./misc/example.test.ts)
2. Применить DI для наших санок.
```typescript
// пример создания
const api = new Api();

export const store = createStore(
  reducer,
  applyMiddleware(thunk.withExtraArgument(api))
)

// пример использования
export const fetchCategories = (params:string) => async (dispatch: Dispatch, _getState: unknown, api: Api) => {
  dispatch(getCategories());

  api.getCategories(params)
    .then((resp) => {
        getCategoriesSuccess(resp)
    })
    .catch(() => {
        dispatch(getCategoriesFailure())
    });
};
```
3. Перевести проект на webpack.
    + Удалить из зависимостей react-scripts ```npm uninstall react-scripts```
    + Отредактировать src/tsconfig.json, изменив noEmit на false ```"noEmit": false,```
    + Отредактировать scripts в pacjakge.json
    ```json
        "scripts": {
        "start": "webpack-dev-server",
        "build": "webpack",
        "test": "jest",
        },
    ```
    + Установить необходимые зависимости ```npm i --save-dev webpack webpack-dev-server webpack-cli```
    + Создаить файл с конфигами src/webpack.config.js и написать конфиги ([пример](./misc/webpack.config.js)).
    + Удостовериться, что все компоненты находятся в tsx файлах.
    + Установить зависимости, которые использовали в конфиге вебпака ```npm i --save-dev style-loader css-loader ts-loader html-webpack-plugin clean-webpack-plugin```
    + Если из-за импортов НЕ js файлов возникают ошибки связанные с отсутсвием лоадеров - поставить необходимые лоадеры.

### Info
asc - ascending - по возрастанию
desc - descending - по убыванию

```javascript
// fetch с подписанным токеном
fetch('/api/cart', headers: { Authorization: `Bearer ${ВАШ_ТОКЕН}` });
```

// пример лоадстатусов
export enum LOAD_STATUSES = {
    UNKNOWN = 'unknown',
    LOADING = 'loading',
    LOADED = 'loaded',
    ERROR = 'error',
}

```typescript
// пример useEffect аналога метода componentDidMount
useEffect(() => {
    dispatch(someAction);
}, [])
```

## Интеграция с бекендом
0. установить `miragejs` / `@faker-js/faker` / `yup` / `jose`  / `lodash.orderby`, скорпировать файл [server.js](https://github.com/fetchMachine/tms-js-pro/blob/feature/goods_final_hm/hms/misc/server_shop.js) с моками бека  себе в проект и импортировать в src/index
1. Для включения / выключения функционала авторизации необходимо изменять значения `APP_CONFIG.USE_AUTH_CHECK` в файле `server.js`
2. Создать класс, ответственный за коммуникацию с бекендом в src/api/Api. Класс должен содержать методы получения данных для каждого ендпоинта (делать fetch запрос, проверять на ok, делать, вызывать .json() и при необходимости трансформировать данные из структуры что отдал бекенд в удобную для вас структуру). Также тут создаем все интерфейсы и наши методы должны возвращать не any, а типизированные объекты
```javascript
interface Good {
    id: string;
    label: string;
    // ...
}
class Api {
    getGoods(): Promise<{ items: Good[]; total: number }> {
        return fetch('/api/goods').then(r => {
            if (r.ok) {
                return r.json()
            }
        });
    }
}
```
2. Использовать статусы загрузки, чтобы отображать лоадер на время загрузки / сообщение об ошибке (тосты), если запрос провалился

## webpack aliases
для глубоко вложенных элементов имеем импорты вида ../../../components/common, что не удобно. Т.к. постоянно надо помнить где находишься в глубине, чтобы корректно их прописать, плюс при рефакторинге и измении глубины придется изменять и импорты. Решением являются алиасы вебпака:

Для этого создаем файл в корне проекта jsconfig.json или tsconfig.json со следующим содержимым:

{
  "compilerOptions": {
    "baseUrl": "src"
  },
  "include": ["src"]
}
